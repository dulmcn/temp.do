---
title: "LLVM中的LTO"
description: "记录学习LLVM中的LTO的过程！"
author: dulm
date: 2024-10-12 17:53:00 +0800
categories: 
tags: [LLVM,LTO]
pin: true
math: true
mermaid: true
---
# LLVM中的LTO（Link-Time Optimization）
## 1、什么是LTO
&emsp;&emsp;链接时优化（Link-Time Optimization, LTO）是链接期间的程序优化。由于编译器一次只编译优化一个编译单元，因此在编译期的很多优化都难以跨编译单元执行，只是在做局部的优化。LTO 就是对整个程序代码进行的一种优化，在链接时将多个中间文件通过链接器合并在一起，进行跨模块间的优化。LTO 聚焦分析整个程序代码，能够大范围地应用过程间优化，从而取得比较好的优化效果，还能够缩减代码体积。
## 2、LTO的使用方式
&emsp;&emsp;llvm中使用LTO的方式如下所示：   
```
  	clang -flto -c a.c -o a.o        # <-- a.o is LLVM bitcode file
  	clang -c main.c -o main.o        # <-- main.o is native object file
  	clang -flto a.o main.o -o main   # <-- standard link command with -flto
```
&emsp;&emsp;在源文件编译时，添加-flto编译选项，这样编译出的.o文件不是目标文件，而是bitcode类型的文件。在链接的时候，lld识别到bitcode类型的输入文件，自动开启LTO。
## 3、LTO的执行流程
&emsp;&emsp;LTO的核心原理是在链接阶段进行全局优化。正常链接与使用LTO的基本流程对比如下：
  ![lto](/assets/pic/image.png)
&emsp;&emsp;图中的
- A）	是正常的编译链接过程：
编译过程中直接生成目标文件；使用链接器将目标文件链接成可执行文件。
- B）则是使用了LTO的执行过程： 
编译生成带有中间表示的目标文件：编译器在编译源文件时，会将每个编译单元（如C/C++中的源文件）生成为包含编译器中间表示（Intermediate Representation，IR）的目标文件。
链接时进行全局优化：在链接阶段，链接器会将所有包含IR的目标文件进行合并，并对整个程序进行全局优化，如去除冗余代码、内联函数等。
生成优化后的目标文件并链接成可执行文件：在生成优化后的目标文件后，链接器将目标文件链接成可执行文件，提高程序的执行效率。
## 4、LTO的分类
&emsp;&emsp;LLVM支持两种模式的 LTO，分别是 FullLTO 和 ThinLTO。
- 1）、FullLTO
我们常用的选项-flto其实代表-flto=full，FullLTO 模式指LTO将分散的目标文件的所有LLVM IR组合到一个大的LLVM模块中，然后对其进行整体分析优化。FullLTO 模式执行流程如下图所示：
 ![fulllto](/assets/pic/image_1.png)
如图中所示，源文件在编译成bitcode格式的文件后，会在链接时合并一个文件，LTO串行的对这一个文件进行优化，并将LTO生成的目标文件继续做链接。
FullLTO 的实现是把所有的输入合并到一个模块，并没有考虑时间和内存的问题，而且还阻碍了增量编译的执行。这意味着 FullLTO 经常需要大量的内存，而且很慢。当源码改变时，FullLTO 的所有步骤都需要被重新执行。
2)、ThinLTO
为了解决FullLTO的弊端，提出了ThinLTO模式。添加编译选项-flto=thin开启ThinLTO模式。ThinLTO 模式的执行流程如下图所示：
![thinlto](/assets/pic/thinlto.png)
如图中所示，编译器将源文件编译为bitcode格式的文件，在执行链接时优化时，ThinLTO模式不会将所有的输入文件合并成一个文件，而是并行的在每个编译单元中执行优化，根据需要才从其他模块导入功能，并且除全局分析外均采用并行的方式进行优化。因此使用-flto=thin比-flto=full编译链接的速度大大加快，这个模式可以允许更快的增量编译，以及使用更少的内存。
